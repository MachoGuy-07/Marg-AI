{"ast":null,"code":"var _s = $RefreshSig$();\n// client/src/components/PostureAnalyzer.jsx\n\nimport { useEffect, useRef } from \"react\";\nimport { FaceMesh } from \"@mediapipe/face_mesh\";\nexport default function PostureAnalyzer({\n  videoRef,\n  onScoreUpdate\n}) {\n  _s();\n  const intervalRef = useRef(null);\n  const meshRef = useRef(null);\n  const faceFrames = useRef(0);\n  const totalFrames = useRef(0);\n  const headMovement = useRef(0);\n  const lastNose = useRef(null);\n  useEffect(() => {\n    if (!(videoRef !== null && videoRef !== void 0 && videoRef.current)) return;\n    let isMounted = true;\n    const faceMesh = new FaceMesh({\n      locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`\n    });\n    meshRef.current = faceMesh;\n    faceMesh.setOptions({\n      maxNumFaces: 1,\n      refineLandmarks: true,\n      minDetectionConfidence: 0.5,\n      minTrackingConfidence: 0.5\n    });\n    faceMesh.onResults(results => {\n      if (!isMounted) return;\n      totalFrames.current++;\n      if (!results.multiFaceLandmarks) return;\n      faceFrames.current++;\n      const landmarks = results.multiFaceLandmarks[0];\n      const leftEye = landmarks[33];\n      const rightEye = landmarks[263];\n      const nose = landmarks[1];\n      const faceWidth = Math.abs(landmarks[234].x - landmarks[454].x);\n      const leftMouth = landmarks[61];\n      const rightMouth = landmarks[291];\n      const mouthWidth = Math.abs(leftMouth.x - rightMouth.x) / faceWidth;\n      let emotion = \"Neutral\";\n      if (mouthWidth > 0.39) emotion = \"Smile\";\n      const eyeCenterX = (leftEye.x + rightEye.x) / 2;\n      const gazeOffset = Math.abs(nose.x - eyeCenterX);\n      const eyeScore = 1 - Math.min(gazeOffset * 3, 1);\n      if (lastNose.current) {\n        const dx = nose.x - lastNose.current.x;\n        const dy = nose.y - lastNose.current.y;\n        headMovement.current += Math.sqrt(dx * dx + dy * dy);\n      }\n      lastNose.current = nose;\n      const engagement = faceFrames.current / totalFrames.current;\n      const stability = Math.max(0, 1 - headMovement.current * 5);\n      const postureScore = eyeScore * 0.4 + engagement * 0.3 + stability * 0.3;\n      onScoreUpdate === null || onScoreUpdate === void 0 ? void 0 : onScoreUpdate(postureScore, emotion);\n    });\n    intervalRef.current = setInterval(async () => {\n      try {\n        if (videoRef.current && videoRef.current.readyState >= 2 && meshRef.current) {\n          await meshRef.current.send({\n            image: videoRef.current\n          });\n        }\n      } catch (err) {\n        console.error(\"FaceMesh send error:\", err);\n      }\n    }, 120);\n    return () => {\n      isMounted = false;\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n      }\n      if (meshRef.current) {\n        meshRef.current.close();\n        meshRef.current = null;\n      }\n    };\n  }, [videoRef, onScoreUpdate]);\n  return null;\n}\n_s(PostureAnalyzer, \"92MBA449e5FjEPVK4J8n57zKLec=\");\n_c = PostureAnalyzer;\nvar _c;\n$RefreshReg$(_c, \"PostureAnalyzer\");","map":{"version":3,"names":["useEffect","useRef","FaceMesh","PostureAnalyzer","videoRef","onScoreUpdate","_s","intervalRef","meshRef","faceFrames","totalFrames","headMovement","lastNose","current","isMounted","faceMesh","locateFile","file","setOptions","maxNumFaces","refineLandmarks","minDetectionConfidence","minTrackingConfidence","onResults","results","multiFaceLandmarks","landmarks","leftEye","rightEye","nose","faceWidth","Math","abs","x","leftMouth","rightMouth","mouthWidth","emotion","eyeCenterX","gazeOffset","eyeScore","min","dx","dy","y","sqrt","engagement","stability","max","postureScore","setInterval","readyState","send","image","err","console","error","clearInterval","close","_c","$RefreshReg$"],"sources":["/Users/siva/Desktop/AI-INTERVIEW/client/src/components/PostureAnalyzer.jsx"],"sourcesContent":["// client/src/components/PostureAnalyzer.jsx\n\nimport { useEffect, useRef } from \"react\";\nimport { FaceMesh } from \"@mediapipe/face_mesh\";\n\nexport default function PostureAnalyzer({ videoRef, onScoreUpdate }) {\n\n  const intervalRef = useRef(null);\n  const meshRef = useRef(null);\n\n  const faceFrames = useRef(0);\n  const totalFrames = useRef(0);\n  const headMovement = useRef(0);\n  const lastNose = useRef(null);\n\n  useEffect(() => {\n\n    if (!videoRef?.current) return;\n\n    let isMounted = true;\n\n    const faceMesh = new FaceMesh({\n      locateFile: (file) =>\n        `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`,\n    });\n\n    meshRef.current = faceMesh;\n\n    faceMesh.setOptions({\n      maxNumFaces: 1,\n      refineLandmarks: true,\n      minDetectionConfidence: 0.5,\n      minTrackingConfidence: 0.5,\n    });\n\n    faceMesh.onResults((results) => {\n\n      if (!isMounted) return;\n\n      totalFrames.current++;\n\n      if (!results.multiFaceLandmarks) return;\n\n      faceFrames.current++;\n\n      const landmarks = results.multiFaceLandmarks[0];\n\n      const leftEye = landmarks[33];\n      const rightEye = landmarks[263];\n      const nose = landmarks[1];\n\n      const faceWidth = Math.abs(landmarks[234].x - landmarks[454].x);\n\n      const leftMouth = landmarks[61];\n      const rightMouth = landmarks[291];\n      const mouthWidth = Math.abs(leftMouth.x - rightMouth.x) / faceWidth;\n\n      let emotion = \"Neutral\";\n      if (mouthWidth > 0.39) emotion = \"Smile\";\n\n      const eyeCenterX = (leftEye.x + rightEye.x) / 2;\n      const gazeOffset = Math.abs(nose.x - eyeCenterX);\n      const eyeScore = 1 - Math.min(gazeOffset * 3, 1);\n\n      if (lastNose.current) {\n        const dx = nose.x - lastNose.current.x;\n        const dy = nose.y - lastNose.current.y;\n        headMovement.current += Math.sqrt(dx * dx + dy * dy);\n      }\n\n      lastNose.current = nose;\n\n      const engagement = faceFrames.current / totalFrames.current;\n      const stability = Math.max(0, 1 - headMovement.current * 5);\n\n      const postureScore =\n        eyeScore * 0.4 +\n        engagement * 0.3 +\n        stability * 0.3;\n\n      onScoreUpdate?.(postureScore, emotion);\n    });\n\n    intervalRef.current = setInterval(async () => {\n\n      try {\n\n        if (\n          videoRef.current &&\n          videoRef.current.readyState >= 2 &&\n          meshRef.current\n        ) {\n          await meshRef.current.send({ image: videoRef.current });\n        }\n\n      } catch (err) {\n        console.error(\"FaceMesh send error:\", err);\n      }\n\n    }, 120);\n\n    return () => {\n\n      isMounted = false;\n\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n      }\n\n      if (meshRef.current) {\n        meshRef.current.close();\n        meshRef.current = null;\n      }\n    };\n\n  }, [videoRef, onScoreUpdate]);\n\n  return null;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}